---
title: "<center>Preliminary Nitrate Investigation</center>"
author: "<center>Jay Shapiro</center>"
date: "<center>Dec 9, 2019</center>"
output:
  html_document:
    theme: darkly
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<br><br>

Topic: Why can the PCA algorithm on the NanoRam 785 differentiate between calcium nitrate and magnesium nitrate, but the RVM algorithm on the NanoRam 1064 cannot?

<br><br>

<center> <h1>Part One: 785 nm</h1> </center>

<br><br>

## Introduction

<br><br>

**Principal component Analysis** (PCA) is a procedure which takes a set of variables and transforms them into a new set of variables which have no collinearity, called **principal components**. **Dimensionality reduction** techniques such as PCA are often used in spectral classification and prediction due to the large number of variables present in each spectrum. Each data point in a spectrum is considered to be a variable, and reducing the number of variables is crucial in creating a meaningful model. PCA uses an approach called feature extraction, which involves creating new features from recombinations of existing variables in order to sufficiently describe a dataset with a smaller amount of variables.

<br><br>

## Results

<br><br>

First, methods containing 20 scans each were built using the B&W Tek handheld Raman analyzer, NanoRam 785, for a single sample of both magnesium nitrate and calcium nitrate. Then the same nitrate samples were measured using a B&W Tek NanoRam 1064 handheld Raman analyzer to create a five scan method for each sample. The raw data was processed with dark subtraction, scaling, and centering. Running PCA on the processed 785 nm spectral data yields the following:

<br><br>

```{r echo = FALSE, warning = FALSE, message = FALSE}
library(plotly)
library(tidyverse)
library(ggplot2)
library(plyr)
library(data.table)
library(readr)
library(dplyr)
library(ggfortify)
library(factoextra)


#Grab the file names of the 20 spectra for 785nm measured Calcium Nitrate
myfiles <- list.files(path = "C:/Users/jays/Desktop/Converted_Spectra/785/Ca_Nitrate", 
                        pattern = "*.txt", full.names = TRUE)

#Instantiate an empty data frame to jam the raw data into
ca_nitrate_785 <- data.frame()

#Loop through the files to build one dataframe
for (lambda in c(1:20)) {
  location <- myfiles[lambda]
  temp <- fread(file = location, 
                sep = ";", fill = TRUE, header = TRUE) %>% select(`Dark Subtracted`)
  
  temp <- transpose(temp)
  
  ca_nitrate_785[lambda, 1:582] <- temp
}


#Repeat above steps for the 20 spectra of 785nm measured Magnesium Nitrate
myfiles <- list.files(path = "C:/Users/jays/Desktop/Converted_Spectra/785/Mg_Nitrate", 
                      pattern = "*.txt", full.names = TRUE)

#Instantiate an empty data frame to jam the raw data into
mg_nitrate_785 <- data.frame()

#Loop through the files
for (lambda in c(1:20)) {
  location <- myfiles[lambda]
  temp <- fread(file = location, 
                sep = ";", fill = TRUE, header = TRUE) %>% select(`Dark Subtracted`)
  
  temp <- transpose(temp)
  
  mg_nitrate_785[lambda, 1:582] <- temp
}

#Slap on an identification column
ca_nitrate_785 <- ca_nitrate_785 %>% mutate(compound = "ca")
mg_nitrate_785 <- mg_nitrate_785 %>% mutate(compound = "mg")

#Create a master dataframe of all 40 spectra
all_785_spectra <- rbind(ca_nitrate_785, mg_nitrate_785)

#Creating the PCA model
simple_pca <- prcomp(all_785_spectra[ , 1:582],
                      center = TRUE,
                      scale = TRUE,
                      rank. = 5)

#Graphical depiction of how the data looks on the PC axes
autoplot(simple_pca, data = all_785_spectra, colour = "compound")
```

<br><br>

### Scree Plots

Scree plots show the eigenvalues of the principal components. The first one depicts the raw values of the variance on the y axis and the principal components in descending order by eigenvalue magnitude: 

<br><br>

```{r echo = FALSE, warning = FALSE, message = FALSE}
#Variance of each principal component
screeplot(simple_pca, npcs = 5)
```


<br><br>


The second plot depicts the percentage of the total variance explained by each principal component, again ordered in descending order by eigenvalue magnitude:

<br><br>

```{r echo = FALSE, warning = FALSE, message = FALSE}
#Explanatory power of each principal component
fviz_eig(simple_pca)
```

<br><br>

### Statistical Summary

The information in the preceding graphs is also displayed analytical in the below table:

<br><br>

```{r echo = FALSE, warning = FALSE, message = FALSE}
#Check out statistics describing how important each PC is                       
summary(simple_pca)
```

<br><br>

### Confidence Ellipses

A 95% confidence ellipse was constructed for each class . Under a large number of repeated sampling from the underlying distribution, and each time calculate a confidence ellipse, 95% of the constructed ellipses would contain the underlying mean of the distribution.

<br><br>

```{r echo = FALSE, warning = FALSE, message = FALSE}
fviz_pca_ind(simple_pca,
              palette = c("#00AFBB",  "#FC4E07"),
              addEllipses = TRUE,
              col.ind = all_785_spectra$compound,
              ellipse.type = "confidence",
              ellipse.level = 0.95,
              legend.title = "Groups",
              repel = TRUE)
```

<br><br>

## Conclusion

The calcium nitrate samples had low in-class variance, but the magnesium nitrate samples had a few massive outliers that significantly raised the variance and heavily affected the PC construction. Furthermore, the between-class variance is fairly small, the two main clusters are right next to each other. Can we do better?

<br><br><br><br>

<center> <h1>Part Two: 785 adjusted</h1> </center>

## Introduction

<br><br>

Scaling before running PCA is a seemingly contentious issue in data science and spectral literature. There is a general consensus that scaling is required when variables have different units or greatly differing standard deviations. However, spectral data variables are all just relative intensities at certain pixels, which means that the variables will have the same units and are all measured on the same scale. Given that these two conditions are met, it would be acceptable and potentially even advantageous not to scale the variables and perform the PCA based on the covariance matrix. Otherwise, scaling the variables and using the correlation matrix to perform the PCA makes more sense.

<br><br>

Outliers can also have a substantial impact on the construction of principal components. From part one, it was immediately obvious that there was an outlier present from the magnesium nitrate group skewing the results of the PCA. Examining the spectra in a spectroscopy software called BWIQ graphically indicates that magnesium nitrate scan #12 is vastly different from the other magnesium nitrate scans and was likely due to human error in taking the scan of the sample. Two other potential outliers are shown in the PCA graph from part one, but spectrally they are not dissimilar to the other samples in the method, and after running PCA again with the largest outlier removed, those two scans are no longer problematic.

<br><br>

## Results

<br><br>

First, methods containing 20 scans each were built using the B&W Tek handheld Raman analyzer, NanoRam 785, for a single sample of both magnesium nitrate and calcium nitrate. The raw data was processed with dark subtraction, and centering. Magnesium nitrate sample scan #12 was removed from the dataset as an outlier. Running PCA on the processed 785 nm spectral data yields the following:

<br><br>

```{r echo = FALSE, warning = FALSE, message = FALSE}
#Retrying PCA model with Mg Nitrate scan #12 outlier removed
all_785_spectra_adjusted <- all_785_spectra[-c(24),]

#Creating the PCA model using SVD method
simple_pca_adjusted <- prcomp(all_785_spectra_adjusted[ , 1:582],
                     center = TRUE,
                     scale = FALSE,
                     rank. = 5)
#Graphical depiction of how the data looks on the PC axes
autoplot(simple_pca_adjusted, data = all_785_spectra_adjusted, colour = "compound")
```

<br><br>

### Scree Plots

<br><br>

```{r echo = FALSE, warning = FALSE, message = FALSE}
#Variance of each principal component
screeplot(simple_pca_adjusted, npcs = 5)
```

<br><br>

```{r echo = FALSE, warning = FALSE, message = FALSE}
#Explanatory power of each principal component
fviz_eig(simple_pca_adjusted)
```


<br><br>


### Statistical Summary

<br><br>


```{r echo = FALSE, warning = FALSE, message = FALSE}
#Check out statistics describing how important each PC is                       
summary(simple_pca_adjusted)
```


<br><br>

### Confidence Ellipses

<br><br>

```{r echo = FALSE, warning = FALSE, message = FALSE}
fviz_pca_ind(simple_pca_adjusted,
             palette = c("#00AFBB",  "#FC4E07"),
             addEllipses = TRUE,
             col.ind = all_785_spectra_adjusted$compound,
             ellipse.type = "confidence",
             ellipse.level = 0.95,
             legend.title = "Groups",
             repel = TRUE)
```

<br><br>

```{r echo = FALSE, warning = FALSE, message = FALSE}
#Retrying PCA model with Mg Nitrate scan #12 outlier removed
all_785_spectra_adjusted <- all_785_spectra[-c(24),]

#Creating the PCA model using SVD method
simple_pca_adjusted <- prcomp(all_785_spectra_adjusted[ , 1:582],
                     center = TRUE,
                     scale = FALSE,
                     rank. = 5)
```

<br><br>

### Interactive 3-Dimensional PCA Scores

<br><br>


```{r echo = FALSE, warning = FALSE, message = FALSE}
scores_785 <- data.frame(simple_pca_adjusted$x)  

p <- plot_ly(scores_785, x = ~PC1, y = ~PC2, z = ~PC3, color = ~all_785_spectra_adjusted$compound, colors = c("#00AFBB",  "#FC4E07")) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))

p
```


<br><br>

<center> <h1>Part Three: 1064 nm PCA</h1> </center>

## Introduction

<br><br>

**Reduced Variable Multivariate** (RVM) is another dimensionality reduction procedure which takes a set of variables and deletes many of the variables until a small subset of variables that accurately describe the dataset remain. RVM uses an approach called **feature deletion**, which differs from feature extraction in a couple ways. First, since variables are just removed instead of being transformed into new ones, there is a loss of data present in feature selection, whereas all of the original data is preserved in feature extraction. Second, there is no guarantee that the variables are free of collinearity in feature selection, while feature extraction does guarantee orthogonal variables with no collinearity. Before attempting to analyze the data collected on the 1064 nm device with RVM, first it will be run through the PCA model as a baseline for comparison.

<br><br>

## Results

<br><br>

```{r echo = FALSE, warning = FALSE, message = FALSE}
#Grab the file names of the 20 spectra for 1064nm measured Calcium Nitrate
myfiles <- list.files(path = "C:/Users/jays/Desktop/Converted_Spectra/1064/Ca_Nitrate", 
                      pattern = "*.txt", full.names = TRUE)

#Instantiate an empty data frame to jam the raw data into
ca_nitrate_1064 <- data.frame()

#Loop through the files to build one dataframe
for (lambda in c(1:5)) {
  location <- myfiles[lambda]
  temp <- fread(file = location, 
                sep = ";", fill = TRUE, header = TRUE) %>% select(`Dark Subtracted`)
  
  temp <- transpose(temp)
  
  ca_nitrate_1064[lambda, 1:582] <- temp
}

#Repeat above steps for the 5 spectra of 1064nm measured Magnesium Nitrate
myfiles <- list.files(path = "C:/Users/jays/Desktop/Converted_Spectra/1064/Mg_Nitrate", 
                      pattern = "*.txt", full.names = TRUE)

#Instantiate an empty data frame to jam the raw data into
mg_nitrate_1064 <- data.frame()

#Loop through the files
for (lambda in c(1:5)) {
  location <- myfiles[lambda]
  temp <- fread(file = location, 
                sep = ";", fill = TRUE, header = TRUE) %>% select(`Dark Subtracted`)
  
  temp <- transpose(temp)
  
  mg_nitrate_1064[lambda, 1:582] <- temp
}

#Slap on an identification column
ca_nitrate_1064 <- ca_nitrate_1064 %>% mutate(compound = "ca")
mg_nitrate_1064 <- mg_nitrate_1064 %>% mutate(compound = "mg")

#Create a master dataframe of all 10 spectra
all_1064_spectra <- rbind(ca_nitrate_1064, mg_nitrate_1064)

#Import the validation files
ca_validation <- fread(file = "C:/Users/jays/Desktop/Converted_Spectra/1064/Validation/Ca_Nitrate_Validation.txt", 
                        sep = ";", fill = TRUE, header = TRUE) %>% select(`Dark Subtracted`) %>% transpose()

mg_validation <- fread(file = "C:/Users/jays/Desktop/Converted_Spectra/1064/Validation/Mg_Nitrate_Validation.txt",
                       sep = ";", fill = TRUE, header = TRUE) %>% select(`Dark Subtracted`) %>% transpose()

#Add identifier to each observation
ca_validation <- ca_validation %>% mutate(compound = "ca_val")
mg_validation <- mg_validation %>% mutate(compound = "mg_val")

#Attach validation observations to master dataset
all_1064_spectra <- rbind(all_1064_spectra, ca_validation, mg_validation)
#str(all_1064_spectra)


simple_pca_1064 <- prcomp(all_1064_spectra[ , 1:582],
                     center = TRUE,
                     scale = FALSE,
                     rank. = 3)

#Graphical depiction of how the data looks on the PC axes
autoplot(simple_pca_1064, data = all_1064_spectra, colour = "compound", size = 3, 
          title = "PCA of Ca Nitrate and Mg Nitrate")
```
 <br><br>
 
 There don't seem to be any outliers present, and learning from the previoius sections, the variables are not scaled in the preprocessing steps.
 
 <br><br>
 
### Scree Plots

```{r echo = FALSE, warning = FALSE, message = FALSE}
#Variance of each principal component
screeplot(simple_pca_1064, npcs = 5)
```

<br><br>

```{r echo = FALSE, warning = FALSE, message = FALSE}
#Explanatory power of each principal component
fviz_eig(simple_pca_1064)
```

<br><br>

### Statistical Summary

<br><br>

```{r echo = FALSE, warning = FALSE, message = FALSE}
#Check out statistics describing how important each PC is                       
summary(simple_pca_1064)
```

<br><br>

### Confidence Ellipses

<br><br>

Currently the ellipses are not being drawn...need to fix error =[

<br><br>

```{r echo = FALSE, warning = FALSE, message = FALSE}
fviz_pca_ind(simple_pca_1064,
             palette = c("#00AFBB",  "#FC4E07", "#3bd95d", "#e3121d"),
             addEllipses = TRUE,
             col.ind = all_1064_spectra$compound,
             ellipse.type = "confidence",
             ellipse.level = 0.95,
             legend.title = "Groups",
             repel = TRUE)
```

<br><br>

### Interactive 3-Dimensional PCA Scores

<br><br>

```{r echo = FALSE, warning = FALSE, message = FALSE}
scores_1064 <- data.frame(simple_pca_1064$x)  

p <- plot_ly(scores_1064, x = ~PC1, y = ~PC2, z = ~PC3, color = ~all_1064_spectra$compound, 
             colors = c("#00AFBB",  "#FC4E07", "#3bd95d", "#e3121d")) %>%
  add_markers() %>%
  layout(scene = list(xaxis = list(title = 'PC1'),
                      yaxis = list(title = 'PC2'),
                      zaxis = list(title = 'PC3')))

p
```

<br><br>

### Conclusion

<br><br>

The PCA algorithm has no trouble distinguising between the two kinds of nitrates on the data from the 1064 nm device either. This would point to a flaw in the RVM algorithm, as the RVM method had specificity issues when examining the nitrate samples on the 1064 nm device. Further investigation will be conducted to uncover the issues the 1064 nm device is having with its current algorithm.

<br><br>

<center> <h1>Part Four: 1064 nm RVM</h1> </center>

<br><br>

## Introduction

<br><br>

I'm eventually going to try to build an RVM algorithm from scratch since I won't be able to get any source code. All I have to go on is that RVM uses feature selection, so there is probably collinearity between the remaining variables, and that a variable inflation factor is applied, which definitely causes a decrease in specificity (more false positives). There appears to be no way to alter the default inflation factor of 5 on the NanoRam 1064, although the internal paper mentions that it can be lowered to deal with false positive issues. For now, I will discuss the potential drawbacks of an RVM method and what I believe to be the root cause of the specificity issues.

<br><br>

### Hypothesis

The number of false negatives using RVM is quite low. The main issue is false positives, i.e. a sample will come up as a positive match for two different methods. As mentioned in the technical paper, there is a variance inflation factor used to increase the variance of each spectrally reduced variable in the RVM method. The claim is that this will reduce the number of false negatives, which of course is true. However, the inflation factor will also inherently cause there to be a greater number of false positives. As I mentioned in the introduction, the technical paper mentions that lowering this inflation factor will increase specificity for distinguishing spectrally similar compounds, but apparently there is no option to perform this action on the actual device. 

<br><br>

An interesting phenomenon sometimes occurs when comparing two spectrally similar compounds. The method for sample A will work perfectly fine, but then the method for sample B will not be able to tell A and B apart, giving false positives for scans of sample A. Why does this occur? It appears that the underlying cause could be related to the spread of the data in each method being different magnitudes. There are a few visual aids that may be able to shed some light on the problem. Notice how the confidence region is artificially boosted for these two distributions:

<br><br>

![](C:/Users/jays/Desktop/Converted_Spectra/1064/Graphs/JunInflationFactor.jpg)

<br><br>

For well-separated spectra like in the above, obviously the confidence regions are not very close together, so it is unlikely that any false positives will occur. However, if the confidence regions are closer together...

<br><br>

![](C:/Users/jays/Desktop/Converted_Spectra/1064/Graphs/SnugEllipses.jpg)

<br><br>

...this can cause issues. Notice the disparity in the area of the ellipses; the (blue) calcium nitrate data  has a much smaller variance than the (orange) magnesium nitrate data, and thus its ellipse has significantly less area. Why does this matter? My intuitive guess is that When a sample of calcium nitrate and magnesium nitrate are run against the calcium nitrate method, the variance multiplication does not increase the area of the blue calcium nitrate ellipse enough to "cross" into the threshold of the orange magnesium nitrate ellipse. This means that the method will be able to properly differentiate between the two samples. However, when the magnesium nitrate method is used, the magnesium nitrate ellipse is much larger to start with, so when the size is scaled up with the inflation factor, it practically devours the calcium nitrate ellipse, leading to a false positive scan against the method. Note that the example uses scans from the 785 device with 20 scans; variance problems will be even higher in the 1064 device because the methods are built using only five scans. Without knowing explicitly how the RVM method works, this is only conjecture, but it gives a conceptual framework for understanding the crux of the issue. The p-value crosstable provides some support for this idea, since the calcium nitrate method has a false positive issue, and that method also has much higher variance on the 1064 scans:

<br><br>

![](C:/Users/jays/Desktop/Converted_Spectra/1064/Graphs/1064crosstable.jpg)

<br><br>

![](C:/Users/jays/Desktop/Converted_Spectra/1064/Graphs/1064spread.jpg)

<br><br>

More investigation will be required to ascertain whether or not this hypothesis is on the right track or not. Examination of other data sets is underway, as is the rogue RVM development. Stay tuned!

<br><br>

<center> <h1>Session Info</h1> </center>
```{r echo = FALSE}
sessionInfo()
```